# Упражнение 6, 12 ноември 2018 г.:

### Задача 1 ###
Да се напише шаблонен клас, реализиращ стек чрез две опашки.

#### Идея за решение ####
Така организираме добавянето и изваждането на елемент, че винаги в едната опашка да има един елемент - последния влязъл. Отбелязваме я като опашка за вадене. При изваждане на елемента, прехвърляме от другата опашка докато в нея остане един елемент и отбелязваме нея като опашка за вадене (защото останалият в нея елемент е последният влязъл, т.е. върха на стека).
Когато добавяме елемент, го добавяме в опашката за вадене, а наличният преди това елемент в нея прехвърляме в другата опашка.

Това решение не е реализирано и тествано от мен, но би трябвало да работи.

### Задача 2 ###
(Контролно) Да се реализира квадратна матрица чрез свързани списъци. Да се изтрият елементите по главния и по вторичния диагонал.

#### Идея за решение ####
Матрицата се реализира като свързан списък от свързани списъци от цели числа (елементите на главния списък са обекти от тип свързан списък, не указатели към node. Всеки елемент на главния списък представлява ред, а вторичните списъци - елементите на този ред.

Елементът с индекси i, j се намира, като установим итератор към началото на главния списък и го преместваме на следващ node i пъти. След това, установяваме към вторичния списък, намиращ се на указания елемент на главния, итератор и го преместваме на следващ node j пъти. 

Забележка: Не можем директно да установяваме указатели и да ги движим (заради енкапсулацията). Реализациите от учебника (които ви препоръчвам да ползвате) имат метод, който установява итератора (член-данна, която е указател към node - current) към началото, и метод, който премества този итератор на следващ node.

За премахването на елементи - идеята е да пресметнем индексите да установим итераторите към всички node-ове, които трябва да се изтрият (по не повече от 2 на всеки вторичен списък), и след това се изтриват от съответните списъци.

### Задача 3 ###
(Контролно) Като се използва стек, да се пресметне стойността на израз, дефиниран по следния начин:
```c++
<израз> := <цифра> | p(<израз>) | s(<израз>)

<цифра> := 0|1|2|3|4|5|6|7|8|9
p(x) = x + 1; p(9) = 0
s(x) = x - 1; s(0) = 9
```c++ 

#### Идея за решение ####
Стекът е от символи. Тръгваме по израза и пъхаме в стека всички цифри и символи 'p' и 's'. Като стигнем затваряща скоба, започваме да вадим (както е дефиниран изразът, всички затварящи скоби са накрая). На всяка стъпка вадим цифра и буква. Изпълняваме съответната операция и вкарваме резултата в стека. Накрая в стека ще остане само една цифра - крайният резултат.

### Задача 4 ###
(Контролно) Като се използва стек, да се пресметне стойността на израз, дефиниран по следния начин:
```c++
<израз> := <цифра> | p(<израз>,<израз>) | s(<израз>,<израз>)

<цифра> := 0|1|2|3|4|5|6|7|8|9
p, s - бинарни операции, приемащи 2 цифри и връщащи резултат - цифра
```c++ 

#### Идея за решение ####
Подобно е на предходната задача, но една идея по-сложно. Не всички затварящи скоби са накрая. Всеки път, когато срещнем затваряща скоба, вадим от стека 2 цифри и буква, изпълняваме операцията и вкарваме резултата в стека. Като стигнем последната затваряща скоба, ще извадим последните символи от стека и ще получим резултата.

### Задача 5 ###
Задача за ханойските кули чрез стек - вижте следващото упражнение.

